[
    {
        "title": "Lambda Expressions",
        "description": "Concise way to represent anonymous functions",
        "code": "// Traditional way\nRunnable r1 = new Runnable() {\n    public void run() {\n        System.out.println(\"Hello\");\n    }\n};\n\n// Lambda expression\nRunnable r2 = () -> System.out.println(\"Hello\");\n\n// With parameters\nList<String> names = Arrays.asList(\"Alice\", \"Bob\");\nnames.forEach(name -> System.out.println(name));",
        "category": "java8"
    },
    {
        "title": "Stream API",
        "description": "Functional-style operations on collections",
        "code": "List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\n\n// Filter and map\nList<Integer> doubled = numbers.stream()\n    .filter(n -> n % 2 == 0)\n    .map(n -> n * 2)\n    .collect(Collectors.toList());\n\n// Sum using reduce\nint sum = numbers.stream()\n    .reduce(0, Integer::sum);",
        "category": "java8"
    },
    {
        "title": "Optional Class",
        "description": "Container to avoid null pointer exceptions",
        "code": "// Creating Optional\nOptional<String> optional = Optional.of(\"Hello\");\nOptional<String> empty = Optional.empty();\n\n// Using Optional\noptional.ifPresent(System.out::println);\n\nString result = optional.orElse(\"Default\");\nString result2 = optional.orElseGet(() -> \"Computed Default\");\n\n// Map and flatMap\nOptional<Integer> length = optional.map(String::length);",
        "category": "java8"
    },
    {
        "title": "Method References",
        "description": "Shorthand notation for lambda expressions",
        "code": "List<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\n\n// Static method reference\nnames.forEach(System.out::println);\n\n// Instance method reference\nnames.stream()\n    .map(String::toUpperCase)\n    .forEach(System.out::println);\n\n// Constructor reference\nSupplier<List<String>> listSupplier = ArrayList::new;",
        "category": "java8"
    },
    {
        "title": "Default Methods",
        "description": "Methods with default implementation in interfaces",
        "code": "interface Vehicle {\n    default void start() {\n        System.out.println(\"Vehicle starting\");\n    }\n    \n    void stop();\n}\n\nclass Car implements Vehicle {\n    @Override\n    public void stop() {\n        System.out.println(\"Car stopping\");\n    }\n}",
        "category": "java8"
    },
    {
        "title": "Functional Interfaces",
        "description": "Interfaces with single abstract method",
        "code": "@FunctionalInterface\ninterface Calculator {\n    int calculate(int a, int b);\n}\n\n// Usage\nCalculator add = (a, b) -> a + b;\nCalculator multiply = (a, b) -> a * b;\n\nint result = add.calculate(5, 3); // 8\nint result2 = multiply.calculate(5, 3); // 15",
        "category": "java8"
    },
    {
        "title": "Stream Collectors",
        "description": "Collecting stream results into collections",
        "code": "List<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\n\n// To List\nList<String> upperNames = names.stream()\n    .map(String::toUpperCase)\n    .collect(Collectors.toList());\n\n// To Set\nSet<String> nameSet = names.stream()\n    .collect(Collectors.toSet());\n\n// Joining strings\nString joined = names.stream()\n    .collect(Collectors.joining(\", \"));",
        "category": "java8"
    },
    {
        "title": "Date-Time API",
        "description": "Modern date and time handling",
        "code": "// Current date and time\nLocalDate today = LocalDate.now();\nLocalTime now = LocalTime.now();\nLocalDateTime dateTime = LocalDateTime.now();\n\n// Creating specific date\nLocalDate birthday = LocalDate.of(1990, Month.JANUARY, 15);\n\n// Date operations\nLocalDate nextWeek = today.plusWeeks(1);\nLocalDate lastMonth = today.minusMonths(1);\n\n// Formatting\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\nString formattedDate = today.format(formatter);",
        "category": "java8"
    },
    {
        "title": "Stream Grouping",
        "description": "Grouping elements using collectors",
        "code": "class Person {\n    String name;\n    int age;\n    Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n\nList<Person> people = Arrays.asList(\n    new Person(\"Alice\", 25),\n    new Person(\"Bob\", 30),\n    new Person(\"Charlie\", 25)\n);\n\n// Group by age\nMap<Integer, List<Person>> byAge = people.stream()\n    .collect(Collectors.groupingBy(p -> p.age));",
        "category": "java8"
    },
    {
        "title": "Parallel Streams",
        "description": "Process streams in parallel for better performance",
        "code": "List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);\n\n// Sequential stream\nint sum1 = numbers.stream()\n    .mapToInt(Integer::intValue)\n    .sum();\n\n// Parallel stream\nint sum2 = numbers.parallelStream()\n    .mapToInt(Integer::intValue)\n    .sum();\n\n// Parallel processing\nnumbers.parallelStream()\n    .forEach(System.out::println);",
        "category": "java8"
    },
    {
        "title": "Stream FlatMap",
        "description": "Flatten nested structures into single stream",
        "code": "List<List<String>> nestedList = Arrays.asList(\n    Arrays.asList(\"a\", \"b\"),\n    Arrays.asList(\"c\", \"d\"),\n    Arrays.asList(\"e\", \"f\")\n);\n\n// Flatten nested lists\nList<String> flatList = nestedList.stream()\n    .flatMap(List::stream)\n    .collect(Collectors.toList());\n\n// Result: [a, b, c, d, e, f]",
        "category": "java8"
    },
    {
        "title": "Predicate Interface",
        "description": "Functional interface for boolean-valued functions",
        "code": "Predicate<Integer> isEven = n -> n % 2 == 0;\nPredicate<Integer> isPositive = n -> n > 0;\n\n// Test predicate\nboolean result = isEven.test(4); // true\n\n// Combine predicates\nPredicate<Integer> isEvenAndPositive = \n    isEven.and(isPositive);\n\nList<Integer> numbers = Arrays.asList(-2, -1, 0, 1, 2, 3, 4);\nList<Integer> filtered = numbers.stream()\n    .filter(isEvenAndPositive)\n    .collect(Collectors.toList());",
        "category": "java8"
    }
]